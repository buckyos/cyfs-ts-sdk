<html>
<header>
    <title>cyfs test</title>
    <!--JSON查看器-->
    <link href="../css/url.css" rel="stylesheet" />
    <link href="../component/jsonTree.css" rel="stylesheet" />
    <script src="../component/jsonTree.js"></script>
    <script src="../cyfs_sdk/cyfs.js"></script>
</header>
    <body>
        <div class='example'>
            <!--图片上传-->
            <div id="uploader">
                <input type="file" id="file_uploader"/>
                <div><button id="file_upload">存储图片到NDN网络...</button></div>
            </div>

            <!--元数据展示区域-->
            <div id="show">
                <div id="named_object_manager">
                    <div id="object_tree">

                    </div>
                </div>
                
                <!--图片展示区域-->
                <div id="image_list">

                </div>
            </div>
        </div>
    </body>
    <script>

        class NDNUrlTest{
            constructor(){
                this.m_object_tree_container =  null;
            }

            init(){
                this.m_sharedStatck = cyfs.SharedObjectStack.open_runtime();
                this.m_router = this.m_sharedStatck.noc_service();
                this.m_ndn_router = this.m_sharedStatck.ndn_service();

                this.m_object_tree_container = document.getElementById("object_tree");
            }

            async run(){
                // 上传文件
                const fileDialog = document.getElementById('file_upload');
                fileDialog.onclick = (e)=>{
                    const files = document.getElementById('file_uploader').files;
                    const fileReader = new FileReader();
                    fileReader.onload = (evt)=> {
                        
                        // 切分文件为多个Chunk
                        const fileBuffer = new Uint8Array(evt.target.result);
                        const fileHash = cyfs.HashValue.hash_data(fileBuffer);
                        
                        // 测试一个文件直接当作一个Chunk
                        const ret = cyfs.ChunkId.calculate(fileBuffer);
                        if(ret.err){
                            console.error("calc chunk id failed, err:", ret.err);
                            return;
                        }

                        const chunkId = ret.unwrap();
                        console.log("chunk id is:", chunkId.to_base_58(), ", chunk len is:{}", chunkId.length());

                        // Chunk文件写入NDN网络
                        this.m_ndn_router.put_chunk({
                            chunk_id: chunkId,
                            chunk_raw: fileBuffer
                        }).then(ret=>{
                            if(ret.err){
                                console.log("put chunk to ndn network, failed:", ret.err);
                                return;
                            }

                            // 创建一个People（这是一个标准对象）
                            // 对象定义：../../src/cyfs-base/objects/people.ts
                            // create(
                            //   owner: Option<ObjectId>, 
                            //   ood_list: Vec<DeviceId>, 
                            //   public_key: PublicKey, 
                            //   area: Option<Area>, 
                            //   name: Option<string>, 
                            //   icon: Option<FileId>
                            // ):People;
                            let people = cyfs.People.create(
                                cyfs.None,
                                new cyfs.Vec([]),
                                new cyfs.RSAPublicKey("rsa1024", new Uint8Array(cyfs.RAW_PUBLIC_KEY_RSA_1024_LENGTH)), // TODO：公玥的创建
                                cyfs.None,
                                cyfs.Some("cyperpunk2077"),
                                cyfs.None,
                                builder=>{
                                    // 忽略创建时间，同一个人不同时间创建的Id一样
                                    // 如果不忽略时间，每次创建的Id不同，从而导致后续创建的File的Id也不同
                                    builder.no_create_time();
                                }
                            );

                            let people_id = people.people_id();
                            let people_object_id = people_id.object_id;

                            console.log("people_object_id:", people_object_id.to_base_58());
                            console.log("fileHash:", fileHash);
                            console.log("fileBuffer.length:", fileBuffer.length);

                            // 创建File对象
                            // create(owner: ObjectId, len: number, hash: HashValue, chunk_list: ChunkList, build?:(builder: FileBuilder)=>void):File;
                            const file = cyfs.File.create(
                                people_object_id,
                                fileBuffer.length,
                                fileHash,
                                new cyfs.ChunkList(true, new cyfs.Vec([chunkId])),
                                builder=>{
                                    // 忽略创建时间，同一个文件不同时间创建的Id一样
                                    // 如果不忽略时间，每次创建的Id不同，一般同一个文件内容不变我们希望Id一样
                                    builder.no_create_time();
                                }
                            );
                            const file_id = file.file_id();
                            const file_object_id = file_id.object_id;

                            // 写入文件元数据到NON网络
                            this.put_object(file).then(ret=>{
                                // 展示图片元数据
                                this.dump(file);

                                // 展示图片
                                const image_list = document.getElementById('image_list');
                                image_list.removeChild(image_list.firstChild);
                                
                                const imageURL = `cyfs://file/${file_object_id.to_base_58()}`;
                                const imageContainer = document.createElement('div');
                                imageContainer.innerText = imageURL;

                                const image = document.createElement('img');
                                image.src = imageURL;
                                image.alt = image.src;
                                image.width = 400;
                                image.height = 400;

                                imageContainer.appendChild(image);

                                console.log("append img:", image.src);
                                image_list.appendChild(imageContainer);
                            });
                        });
                    };
                    fileReader.readAsArrayBuffer(files[0]);
                };
            }

            // 发送一个对象
            async put_object(obj){
                const object_id = obj.desc().calculate_id();
                const buf = new Uint8Array(obj.raw_measure().unwrap());
                const _ = obj.raw_encode(buf).unwrap();
                const put_req = {
                    object_id: object_id.clone(),
                    object_raw: buf,
                    target: undefined, // 可选指定目标设备id
                    flags: 0,
                };

                const ret = await this.m_router.put_object(put_req);
                if(ret.err){
                    console.error(`"put_object [${object_id.to_base_58()}] failed! ${ret.err}`);
                    return;
                }

                console.log("put object result:", ret);
                return;
            }

            // 显式一个对象
            async dump(obj){
                if(this.object_tree!=null){
                    this.object_tree.clear();
                }

                const filterRooters = ["m_ctx","m_obj_flags"];
                
                this.object_tree = jsonTree.create([obj], this.m_object_tree_container, (label)=>{
                    return filterRooters.indexOf(label)>=0;
                },(keys)=>{
                    // console.log("keys", keys);
                    if(keys.indexOf("m_ctx")>=0&&keys.indexOf("m_desc")>=0){
                        return [
                            "m_obj_type",
                            "m_object_id",
                            "m_desc",
                            "m_body",
                            "m_signs",
                            "m_nonce",
                        ];
                    }else{
                        const type_index = keys.indexOf('m_obj_type');
                        if(type_index>=0){
                            keys.splice(type_index,1).sort();
                            return [...keys];
                        }else{
                            return keys.sort();
                        }
                    }
                });
            }
        }

        // 启动
        const urlTest = new NDNUrlTest();
        urlTest.init();
        urlTest.run();

    </script>
</html>